在 Java 面试中，**双亲委派机制（Parents Delegation Model）** 是类加载器（ClassLoader）的核心面试题。

简单来说，它的核心思想是：**“向上委派，向下加载。”**

---

### 1. 类加载器的层次结构

Java 默认提供了三层类加载器，它们之间不是继承关系，而是**组合关系**：

1. **Bootstrap ClassLoader（启动类加载器）**：
    
    - 由 C++ 实现，是 JVM 的一部分。
        
    - 负责加载核心类库（如 `rt.jar`、`java.lang.*` 等）。
        
2. **Extension ClassLoader（扩展类加载器）**：
    
    - 负责加载标准扩展目录（`jre/lib/ext`）中的 jar 包。
        
3. **App ClassLoader（系统类加载器）**：
    
    - 也叫应用类加载器。负责加载环境变量 `classpath` 下的类，也就是程序员写的代码。
        
4. **Custom ClassLoader（自定义类加载器）**：
    
    - 用户根据需求自己定义的加载器。
        

---

### 2. 双亲委派的工作流程

当一个类加载器收到了类加载的请求，它不会自己先去加载，而是：

1. **向上委派**：把这个请求委托给父类加载器去完成。
    
2. **递归处理**：父类加载器又会委托给它的父类，直到传到顶层的 **Bootstrap ClassLoader**。
    
3. **向下检查**：
    
    - 顶层加载器检查能否加载（即在其搜索范围内是否能找到该类）。
        
    - 如果**能**加载，就成功返回；
        
    - 如果**不能**加载，再子加载器才会尝试自己去加载。
        

---

### 3. 为什么要这么设计？（核心价值）

这是面试官最看重的一点，主要有两个原因：

- **安全性（沙箱机制）**：
    
    防止核心 API 被随意篡改。假设你写了一个 `java.lang.String` 类，双亲委派机制会保证最终加载的是 JDK 自带的那个 String，而不是你写的那个“假”String。这样可以避免恶意代码替换掉基础类。
    
- **避免重复加载**：
    
    通过委派，保证同一个类只会被加载一次，节省内存。
    

---

### 4. 面试加分：如何破坏双亲委派？

面试官可能会问：“所有的类加载都必须遵循双亲委派吗？”答案是：**不一定。**

常见的破坏场景有：

1. **SPI 机制（Service Provider Interface）**：
    
    - 例如 **JDBC**。核心 Java 库（由 Bootstrap 加载）需要调用第三方厂商实现的驱动代码（在 Classpath 下）。由于父类加载器不能直接看到子类加载器加载的类，JDK 引入了 **线程上下文类加载器（Thread Context ClassLoader）** 来逆向加载，从而破坏了委派模型。
        
2. **热部署/热插拔**：
    
    - 像 **OSGi** 技术或早期的 **Tomcat** 为了实现同一个应用内不同版本的类隔离，会自定义类加载器，先自己加载，不符合再向上委派。
        

---

### 5. 总结口诀

>**收到请求不自干，先找父类向上搬；**
> 
> **父类加载没戏看，自领任务才开干。**
