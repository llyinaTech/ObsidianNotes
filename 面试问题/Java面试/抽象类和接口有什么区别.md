简单来所，接口（Interface）是对**行为**的抽象，而抽象类（Abstract Class）是对**本质**的抽象。
##### 1. 核心区别对比表

|  **特性**   |       **抽象类 (Abstract Class)**       |                **接口 (Interface)**                |
| :-------: | :----------------------------------: | :----------------------------------------------: |
| **定义关键词** |           `abstract class`           |                   `interface`                    |
| **继承/实现** |       子类使用 `extends` (**单继承**)       |           实现类使用 `implements` (**多实现**)           |
| **成员变量**  |         可以有各种类型的变量（静态、实例、常量）         |        只能是隐式的公有静态常量 `public static final`        |
| **构造函数**  |         **有**，用于子类实例化时初始化父类          |                      **没有**                      |
| **方法实现**  |          可以包含抽象方法和**具体方法**           | Java 8前只能有抽象方法；Java 8+支持 `default` 和 `static` 方法 |
| **访问修饰符** | 可以是 `public`, `protected`, `default` |                 默认且只能是 `public`                  |
#### 2.设计意图的不同
##### A. “是不是” vs “能不能”
- **抽象类 (Is-A)：** 代表的是一种**所属关系**。例如 `Bird` 是抽象类，`Eagle` 继承它，因为老鹰“是一个”鸟。它提取了子类的共同属性（翅膀、颜色）。
    
- **接口 (Has-A / Can-Do)：** 代表的是一种**行为契约**。例如 `Flyable` 是接口，`Eagle` 和 `Airplane` 都可以实现它。老鹰和飞机没有血缘关系，但它们“都能”飞。
##### B.模板设计 vs 解耦
- **抽象类**常用于**代码复用**。它像是一个模板，把通用的代码逻辑写好，剩下的让子类去实现。
    
- **接口**常用于**解耦**。它只定义规范，不关心具体的实现细节，方便在不同模块间进行交互（面向接口编程）。
#### 3.既然 Java 8 之后接口也能写默认方法（default methods）了，那还要抽象类干嘛？

虽然接口功能增强了，但它依然不能取代抽象类。最关键的一点是**状态的管理**：接口不能有**非静态的成员变量（实例变量）**。如果你需要保存子类的状态（比如每个动物都有不同的 `age` 变量），依然必须使用抽象类。