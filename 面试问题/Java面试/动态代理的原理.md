动态代理是 Java 中一个非常“高级”且核心的特性，它是 **Spring AOP**、**RPC 框架**（如 Dubbo）、以及 **MyBatis** 等框架的灵魂。

简单来说，动态代理就是在程序**运行时**，动态地创建一个代理对象，代替原对象执行业务逻辑，并在这个过程中插入“私货”（如日志、事务、权限校验）。

---

### 1. 为什么要用动态代理？

如果不用代理，你想给每个方法加个日志，你得在每个类里手动写一遍。如果有 100 个类，你会写疯掉。

- **静态代理**：虽然能解决问题，但一个业务类对应一个代理类，代码量依然巨大。
    
- **动态代理**：只需要写一个代理逻辑，就能代理成千上万个不同的类。
    

---

### 2. Java 中的两种主流实现方式

#### A. JDK 动态代理（原生实现）

- **核心原理**：利用反射机制。要求目标类**必须实现接口**。
    
- **关键类**：`Proxy` 类和 `InvocationHandler` 接口。
    
- **执行流程**：
    
    1. 通过 `Proxy.newProxyInstance()` 创建代理对象。
        
    2. 调用代理对象的方法时，请求会被转发到 `InvocationHandler` 的 `invoke()` 方法中。
        
    3. 在 `invoke()` 里执行增强逻辑，最后通过 `Method.invoke()` 反射调用原始对象。
        

#### B. CGLIB 动态代理（第三方库）

- **核心原理**：利用 **继承** 机制。通过修改字节码生成目标类的**子类**。
    
- **特点**：目标类不需要实现接口，但目标类不能是 `final` 的（因为 `final` 类不能被继承）。
    
- **执行流程**：
    
    1. 使用 `MethodInterceptor` 拦截所有父类方法的调用。
        
    2. 通过生成的子类重写父类方法，在子类方法中调用增强逻辑。
        

---

### 3. 两者对比表

| **特性**        | **JDK 代理**            | **CGLIB 代理**     |
| ------------- | --------------------- | ---------------- |
| **实现原理**      | 运行时生成接口的实现类（反射）       | 运行时生成目标类的子类（字节码） |
| **强制要求**      | 目标类必须实现 **Interface** | 目标类不能为 **final** |
| **性能**        | 早期较慢，Java 8 后性能极高     | 创建对象较慢，执行效率略高    |
| **Spring 选择** | 如果有接口，默认用 JDK         | 如果没接口，强制用 CGLIB  |

---

### 4. 深度解析：动态代理是怎么生成的？（加分项）

 **字节码生成**：

> “其实动态代理的本质是在内存中直接生成了 `.class` 文件的字节码。
> 
> - 对于 **JDK 代理**，它生成的类名通常是 `$Proxy0`。
>     
> - 对于 **CGLIB**，它使用 ASM 框架来直接操纵字节码，生成更复杂的子类结构。
>     
>     这种在内存中‘凭空’造出一个类并实例化的能力，就是动态代理强大的原因。”
>     

---

### 5. 简单代码示例 (JDK)

Java

``` java
// 1. 定义接口
public interface Service { void execute(); }

// 2. 实现 InvocationHandler
public class MyHandler implements InvocationHandler {
    private Object target; // 目标对象
    public MyHandler(Object target) { this.target = target; }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("--- 开启事务 ---"); // 增强逻辑
        Object result = method.invoke(target, args); // 执行原逻辑
        System.out.println("--- 提交事务 ---");
        return result;
    }
}
```
### 6. 简单代码示例 (CGLIB）

要实现 CGLIB 代理，主要涉及两个类：

- **`Enhancer`**：这是 CGLIB 的字节码增强器，所有的代理对象都是通过它来创建的。你可以把它理解为“代理工厂”。
    
- **`MethodInterceptor`**：这是一个接口，类似于 JDK 的 `InvocationHandler`。它只有一个 `intercept` 方法，所有的拦截逻辑都写在这里。

假设我们有一个没有实现接口的普通类 `UserService`：

``` java
// 目标类：没有接口
public class UserService {
    public void save() {
        System.out.println("正在保存用户数据...");
    }
}
```

我们要通过 CGLIB 对其进行代理：

``` java
import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;
import java.lang.reflect.Method;

// 1. 实现拦截器
public class MyMethodInterceptor implements MethodInterceptor {
    /**
     * o: 代理对象
     * method: 被拦截的方法
     * args: 参数
     * proxy: 代理方法（用于调用父类方法，性能比反射更高）
     */
    @Override
    public Object intercept(Object o, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        System.out.println(">>> CGLIB日志：方法开始执行");
        
        // 注意：这里调用的是 invokeSuper，即调用父类（原类）的方法
        Object result = proxy.invokeSuper(o, args);
        
        System.out.println(">>> CGLIB日志：方法执行结束");
        return result;
    }
}

// 2. 测试调用
public class CglibTest {
    public static void main(String[] args) {
        // 创建增强器
        Enhancer enhancer = new Enhancer();
        // 设置要继承的目标类
        enhancer.setSuperclass(UserService.class);
        // 设置回调拦截器
        enhancer.setCallback(new MyMethodInterceptor());
        
        // 创建代理对象
        UserService proxy = (UserService) enhancer.create();
        // 执行方法
        proxy.save();
    }
}
```