#### 1.内部调用（最常见）

**现象：** 在同一个类中，一个没有事务的方法 A 调用了带 `@Transactional` 的方法 B。
**原因：** Spring 事务是基于 **AOP（动态代理）** 实现的。只有当外部通过代理对象调用方法时，事务增强逻辑才会生效。类内部的方法直接互相调用是直接通过 `this` 指向原对象，绕过了代理类，导致注解失效。
#### 2.修饰符错误

**现象**：将 `@Transactional` 加在 `private`、`protected` 或 `static` 方法上。
**原因：** Spring 的 AOP 默认要求被代理的方法必须是 **`public`** 的。如果是私有方法，动态代理无法重写该方法，自然无法织入事务逻辑。
#### 3. 异常被“吃掉”了

**现象：** 代码里写了 `try-catch` 块，并在 `catch` 中消化了异常。 
**原因：** Spring 事务捕获回滚的触发条件是：**该方法必须向外抛出未捕获的异常**。如果你手动 `catch` 了异常且没有重新抛出（`throw`），Spring 会认为程序执行成功，从而正常提交。

#### 4. 异常类型不匹配

**现象：** 抛出了一个 `Checked Exception`（受检异常，如 `IOException`），但事务没回滚。
**原因：** Spring 默认只对 **`RuntimeException`** 和 **`Error`** 进行回滚。
**解决方法：** 使用 `@Transactional(rollbackFor = Exception.class)`。

#### 5. 数据库引擎不支持

**现象：** 代码配置全都对，但就是不回滚。 **原因：** 数据库表本身不支持事务。
**例子：** MySQL 的 **MyISAM** 引擎不支持事务，必须切换到 **InnoDB**。

#### 6. 传播行为（Propagation）设置不当

**现象：** 某些操作莫名其妙地提交了，或者没跟着主事务一起回滚。 **原因：** 如果设置了特殊的传播属性，比如：

- `NOT_SUPPORTED`：以非事务方式运行。
    
- `NEVER`：不支持事务，有事务就抛异常。
    
- `REQUIRES_NEW`：挂起当前事务，开启独立新事务（新事务失败不影响旧事务）

#### 7. Bean 未被 Spring 管理

**现象：** 注解写了，但完全没反应。 
**原因：** 如果你忘记在类上加 `@Service` 或 `@Component`，或者没开启组件扫描，该类就不是一个 Spring Bean，Spring 无法为其创建代理对象。